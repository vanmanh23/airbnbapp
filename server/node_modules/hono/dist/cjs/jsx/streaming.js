"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var streaming_exports = {};
__export(streaming_exports, {
  Suspense: () => Suspense,
  renderToReadableStream: () => renderToReadableStream
});
module.exports = __toCommonJS(streaming_exports);
var import_html = require("../helper/html");
let suspenseCounter = 0;
async function childrenToString(children) {
  try {
    return children.map((c) => c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      await e;
      return childrenToString(children);
    } else {
      throw e;
    }
  }
}
const Suspense = async ({ children, fallback }) => {
  if (!children) {
    return fallback.toString();
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  let resArray = [];
  try {
    resArray = children.map((c) => c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      resArray = [e.then(() => childrenToString(children))];
    } else {
      throw e;
    }
  }
  if (resArray.some((res) => res instanceof Promise)) {
    const index = suspenseCounter++;
    return (0, import_html.raw)(`<template id="H:${index}"></template>${fallback.toString()}<!--/$-->`, [
      Promise.all(resArray).then((htmlArray) => {
        htmlArray = htmlArray.flat();
        const html = `<template>${htmlArray.join("")}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${index}')
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
<\/script>`;
        if (htmlArray.every((html2) => !html2.promises?.length)) {
          return html;
        }
        return (0, import_html.raw)(html, htmlArray.map((html2) => html2.promises || []).flat());
      })
    ]);
  } else {
    return (0, import_html.raw)(resArray.join(""));
  }
};
const textEncoder = new TextEncoder();
const renderToReadableStream = (str) => {
  const reader = new ReadableStream({
    async start(controller) {
      const resolved = str instanceof Promise ? await str : await str.toString();
      controller.enqueue(textEncoder.encode(resolved));
      let resolvedCount = 0;
      const promises = [];
      const then = (promise) => {
        promises.push(
          promise.catch((err) => {
            console.trace(err);
            return "";
          }).then((res) => {
            if (res.promises) {
              const resPromises = res.promises || [];
              resPromises.forEach(then);
            }
            resolvedCount++;
            controller.enqueue(textEncoder.encode(res));
          })
        );
      };
      resolved.promises?.map(then);
      while (resolvedCount !== promises.length) {
        await Promise.all(promises);
      }
      controller.close();
    }
  });
  return reader;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Suspense,
  renderToReadableStream
});
